#!/usr/bin/env python
# coding: utf-8

# In[1]:
import os

import pandas as pd
import numpy as np 
import gpxpy
import gpxpy.gpx

import matplotlib.pyplot as plt



# # Analysis of Cycling Data
# 
# We are provided with four files containing recordings of cycling activities that include GPS location data as
# well as some measurements related to cycling performace like heart rate and power.  The goal is to perform
# some exploration and analysis of this data. 
# 
# The data represents four races.  Two are time trials where the rider rides alone on a set course.  Two are 
# road races where the rider rides with a peleton.  All were held on the same course but the road races include
# two laps where the time trials include just one. 
# 
# Questions to explore with the data:
# * What is the overall distance travelled for each of the rides? What are the average speeds etc.  Provide a summary for each ride.
# * Compare the range of speeds for each ride, are time trials faster than road races? 
# * Compare the speeds achieved in the two time trials (three years apart).  As well as looking at the averages, can you see where in the ride one or the other is faster.  
# * From the elevation and distance variable you can calculate __gradient__ to see whether the rider is climbing, descending or on the flat.   Use this to calculate the average speeds in those three cases (climbing, flat or descending).  Note that _flat_ might not be zero gradient but might allow for slight climbs and falls.  
# 
# For time varying data like this it is often useful to _smooth_ the data using eg. a [rolling mean](https://pandas.pydata.org/pandas-docs/version/0.17.0/generated/pandas.rolling_mean.html).  You might want to experiment with smoothing in some of your analysis. 

# ## Description of Fields
# 
# * _index_ is a datetime showing the time that the observation was made (I wasn't riding at night, this is converted to UTC)
# * __latitude, longitude, elevation__ from the GPS, the position of the rider at each timepoint
# * __temperature__ the current ambient temperature in degrees celcius
# * __power__ the power being generated by the rider in Watts
# * __cadence__ the rotational speed of the pedals in revolutions per second
# * __hr__ heart rate in beats per minute
# * __distance__ distance travelled between observations in km
# * __speed__ speed measured in km/h
# 
# You are provided with code in [gpxutils.py](gpxutils.py) to read the GPX XML format files that are exported by cycling computers and applications.  The sample files were exported from [Strava](https://strava.com/) and represent four races by Steve Cassidy.
# 

# In[3]:

import math

def getDistance(lat1,lon1,lat2,lon2):
    # This uses the haversine formula, which remains a good numberical computation,
    # even at small distances, unlike the Shperical Law of Cosines.
    # This method has ~0.3% error built in.
    R = 6371 # Radius of Earth in km

    dLat = math.radians(float(lat2) - float(lat1))
    dLon = math.radians(float(lon2) - float(lon1))
    lat1 = math.radians(float(lat1))
    lat2 = math.radians(float(lat2))

    a = math.sin(dLat/2) * math.sin(dLat/2) + \
        math.cos(lat1) * math.cos(lat2) * math.sin(dLon/2) * math.sin(dLon/2)

    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))

    d = R * c * 0.621371 # Converting km to miles with "* 0.621371"
    if (d ==0):
        print("okay")
    return d


def getInfo(gpx):
    #this function is to get the information from gpx file
    #return value is [total Length, average speed]
    totalLength = 0
    allPoints =[]
    for track in gpx.tracks:
        for segment in track.segments:
            for point in segment.points:                
                points = [point.latitude, point.longitude, point.time]
                allPoints.append(points)
                
    #input all the values to allPoints
    for index, object in enumerate(allPoints):
        if ( index == 0) :
            continue;
        else:
            totalLength += getDistance(allPoints[index][0], allPoints[index][1], allPoints[index-1][0], allPoints[index-1][1])
    #get the total time span
    timespan = allPoints[len(allPoints)-1][2]-allPoints[0][2]
    #get the average speed
    averageSpeed = 1609.34*totalLength/timespan.total_seconds()
    #return the value
    result = [totalLength, averageSpeed]
    return result
    
def getGradient(gpx):
    #this function is to get the information from gpx file
    allPoints =[]
    for track in gpx.tracks:
        for segment in track.segments:
            for point in segment.points:                
                points = [point.latitude, point.longitude, point.time, point.elevation]
                allPoints.append(points)
    data =[]
    distance =0
    speedUp = []
    speedDown = []
    speedFlat = []
    #input all the values to allPoints
    for index, object in enumerate(allPoints):
        if ( index == 0) :
            continue;
        else:
            temp = 1609.34 * getDistance(allPoints[index][0], allPoints[index][1], allPoints[index-1][0], allPoints[index-1][1])
            timespan = allPoints[index][2] - allPoints[index-1][2]
            distance += temp
            ele = allPoints[index][3]
            #calculate the difference between elevation
            eleSpan = ele - allPoints[index-1][3]
            #skip when the distance is zero
            if (temp ==0):
                gradient =0
            else:
                gradient = eleSpan/temp
            #print(gradient)
            if (gradient>0):
                speedUp.append(temp/timespan.total_seconds())
            if (gradient<-0):
                speedDown.append(temp/timespan.total_seconds())
            else:
                speedFlat.append(temp/timespan.total_seconds())
            data.append([distance, ele,gradient])
    averageSpeedUp = sum(speedUp)/len(speedUp)
    averageSpeedDown = sum(speedDown)/len(speedDown)
    averageSpeedFlat = sum(speedFlat)/len(speedFlat)
    average = [averageSpeedUp,averageSpeedDown,averageSpeedFlat]
    result = []
    result.append(data)
    result.append(average)
    return result

def plotSpeed(arr):
    #shwing the elevation
    x =[]
    y = []
    for index, object in enumerate(arr[0]):
        x.append(object[0])
        y.append(object[1])
    plt.plot( x ,y)
    plt.show()
    #showing the speed
    # x-coordinates of left sides of bars 
    left = [1, 2, 3]
    # heights of bars
    height = arr[1]
    # labels for bars
    tick_label = ['SpeedUp', 'SpeedDown', 'SpeedFlat']
    # plotting a bar chart
    plt.bar(left, height, tick_label = tick_label,
            width = 0.8, color = ['red', 'green', 'blue'])
    # naming the x-axis
    plt.xlabel('x - axis')
    # naming the y-axis
    plt.ylabel('y - axis')
    # plot title
    plt.title('My bar chart!')
    # function to show the plot
    plt.show()

def getExtensions(gpx):
    cads =[]
    allPoints =[]
    for track in gpx.tracks:
        for segment in track.segments:
            for point in segment.points:        
                points = [point.latitude, point.longitude, point.time, point.elevation]
                allPoints.append(points)
                for extension in point.extensions:
                    cads.append(extension[2].text)
                    #input all the values to allPoints
    for index, object in enumerate(allPoints):
        if ( index == 0) :
            continue;
        else:
            temp = 1609.34 * getDistance(allPoints[index][0], allPoints[index][1], allPoints[index-1][0], allPoints[index-1][1])
            
                  
    return cads
                    
        
# read the four data files
gpx_file = open('D:/CurrentTask/2021-5-27/Files/files/Calga_TT_2016.gpx', 'r')

rr_2016 = open('D:/CurrentTask/2021-5-27/Files/files/Calga_RR_2016.gpx')
tt_2016 = open('D:/CurrentTask/2021-5-27/Files/files/Calga_TT_2016.gpx')
rr_2019 = open('D:/CurrentTask/2021-5-27/Files/files/Calga_RR_2019.gpx')
tt_2019 = open('D:/CurrentTask/2021-5-27/Files/files/Calga_TT_2019.gpx')

gpx_rr_2016 = gpxpy.parse(rr_2016)
gpx_tt_2016 = gpxpy.parse(tt_2016)
gpx_rr_2019 = gpxpy.parse(rr_2019)
gpx_tt_2019 = gpxpy.parse(tt_2019)

result_rr_2016 = getInfo(gpx_rr_2016)
result_tt_2016 = getInfo(gpx_tt_2016)
result_rr_2019 = getInfo(gpx_rr_2019)
result_tt_2019 = getInfo(gpx_tt_2019)

#showing the speed
tt_speed = [result_tt_2016[1], result_tt_2019[1]]
rr_speed = [result_rr_2016[1], result_rr_2019[1]]
plt.plot([1,1], tt_speed ,'bo')
plt.plot([2,2], rr_speed ,'rs')

#compare the tt speed
plt.plot([1,2], tt_speed , 'bo')

#showing the gradient
ele_tt_2016 = getGradient(gpx_tt_2016)
plotSpeed(ele_tt_2016)
ele_tt_2019 = getGradient(gpx_tt_2019)
plotSpeed(ele_tt_2019)
ele_rr_2016 = getGradient(gpx_rr_2016)
plotSpeed(ele_rr_2016)
ele_rr_2019 = getGradient(gpx_rr_2019)
plotSpeed(ele_rr_2019)

cads_tt_2016 = getExtensions(gpx_tt_2016)
# In[ ]:





# ## Challenge: Gear Usage
# 
# A modern race bike has up to 22 different gears with two chainrings on the front (attached to the pedals) and 10 or 11 at the back (attached to the wheel).   The ratio of the number of teeth on the front and rear cogs determines the distance travelled with one revolution of the pedals (often called __development__, measured in metres).  Low development is good for climbing hills while high development is for going fast downhill or in the final sprint. 
# 
# We have a measure of the number of rotations of the pedals per minute (__cadence__) and a measure of __speed__.  Using these two variables we should be able to derive a measure of __development__ which would effectivly tell us which gear the rider was using at the time.   Development will normally range between __2m__ and __10m__.  Due to errors in GPS and cadence measurements you will see mamy points outside this range and you should just discard them as outliers. 
# 
# Write code to calculate __development__ in _meters_ for each row in a ride.  Plot the result in a _histogram_ and compare the plots for the four rides.   Comment on what you observe in the histograms.
# 
# 

# In[ ]:




